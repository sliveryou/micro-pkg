# 枚举类型方法生成工具 enumer

## 介绍

[enumer](https://github.com/alvaroloes/enumer) 是一个生成 Go 代码的工具，它可以向 Go 枚举（具有特定类型的常量）添加有用的方法。它最初是 Rob Pike 的 [Stringer](https://pkg.go.dev/golang.org/x/tools/cmd/stringer) 工具的一个分支。

## 安装

使用如下命令下载并安装 enumer 工具：

```bash
# 如果 go 版本在 1.16 以前，使用如下命令安装：
$ GO111MODULE=on go get -u github.com/alvaroloes/enumer@latest

# 如果 go 版本在 1.16 及以后，使用如下命令安装：
$ GO111MODULE=on go install github.com/alvaroloes/enumer@latest
```

## enumer 命令行接口

```bash
$ enumer --help
Usage of enumer:
	enumer [flags] -type T [directory]
	enumer [flags] -type T files... # Must be a single package
For more information, see:
	https://github.com/alvaroloes/enumer
Flags:
  -comment value
    	comments to include in generated code, can repeat. Default: ""
  -json
    	if true, json marshaling methods will be generated. Default: false
  -linecomment
    	use line comment text as printed text when present
  -output string
    	output file name; default srcdir/<type>_string.go
  -sql
    	if true, the Scanner and Valuer interface will be implemented.
  -text
    	if true, text marshaling methods will be generated. Default: false
  -transform string
    	enum item name transformation method. Default: noop (default "noop")
  -trimprefix string
    	transform each item name by removing a prefix. Default: ""
  -type string
    	comma-separated list of type names; must be set
  -yaml
    	if true, yaml marshaling methods will be generated. Default: false
```

选项很多，一般我们关注以下几个选项即可：

- **-type**：逗号分隔的类型名称列表，注意逗号间不要有空格，且原始类型为数字类型（如 int、int64 等）
- **-json**：指定后会为类型生成 MarshalJSON 和 UnmarshalJSON 方法
- **-linecomment**：指定后会使用类型的行注释作为枚举字符串释义
- **-output**：为类型生成方法后的输出文件名称

## 使用示例

假设我们有如下几个类型定义在 `enum.go` 文件中：

```go
package types

// EventHandleStatus 事件处置状态
type EventHandleStatus int64

// 事件处置状态枚举
const (
	EventHandleStatusPreHandle     EventHandleStatus = 0 // 未处置
	EventHandleStatusInHandle      EventHandleStatus = 1 // 处置中
	EventHandleStatusNotHandle     EventHandleStatus = 2 // 不处置
	EventHandleStatusFalsePositive EventHandleStatus = 3 // 误报
)

// EventLevel 事件等级
type EventLevel int64

// 事件等级枚举
const (
	EventLevelNone   EventLevel = 0 // 无等级
	EventLevelLow    EventLevel = 1 // 低级
	EventLevelMedium EventLevel = 2 // 中级
	EventLevelHigh   EventLevel = 3 // 高级
)
```

我们可以在文件上方加入注解：

```go
//go:generate enumer -type EventHandleStatus,EventLevel -json -linecomment -output enum_string.go
```

这段注解含义为：为 `EventHandleStatus` 和 `EventLevel` 类型生成枚举方法与 json 方法，并使用行注释作为枚举字符串定义，方法将会生成至 enum_string.go 文件中。

之后我们在文件所在目录下，执行 `go generate` 命令即可。使用 Goland 的同学也可以点击运行标志，生成代码。

`enum_string.go` 生成代码示例：

```go
// Code generated by "enumer -type EventHandleStatus,EventLevel -json -linecomment -output enum_string.go"; DO NOT EDIT.

package types

import (
	"encoding/json"
	"fmt"
)

const _EventHandleStatusName = "未处置处置中不处置误报"

var _EventHandleStatusIndex = [...]uint8{0, 9, 18, 27, 33}

func (i EventHandleStatus) String() string {
	if i < 0 || i >= EventHandleStatus(len(_EventHandleStatusIndex)-1) {
		return fmt.Sprintf("EventHandleStatus(%d)", i)
	}
	return _EventHandleStatusName[_EventHandleStatusIndex[i]:_EventHandleStatusIndex[i+1]]
}

var _EventHandleStatusValues = []EventHandleStatus{0, 1, 2, 3}

var _EventHandleStatusNameToValueMap = map[string]EventHandleStatus{
	_EventHandleStatusName[0:9]:   0,
	_EventHandleStatusName[9:18]:  1,
	_EventHandleStatusName[18:27]: 2,
	_EventHandleStatusName[27:33]: 3,
}

// EventHandleStatusString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func EventHandleStatusString(s string) (EventHandleStatus, error) {
	if val, ok := _EventHandleStatusNameToValueMap[s]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to EventHandleStatus values", s)
}

// EventHandleStatusValues returns all values of the enum
func EventHandleStatusValues() []EventHandleStatus {
	return _EventHandleStatusValues
}

// IsAEventHandleStatus returns "true" if the value is listed in the enum definition. "false" otherwise
func (i EventHandleStatus) IsAEventHandleStatus() bool {
	for _, v := range _EventHandleStatusValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for EventHandleStatus
func (i EventHandleStatus) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for EventHandleStatus
func (i *EventHandleStatus) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("EventHandleStatus should be a string, got %s", data)
	}

	var err error
	*i, err = EventHandleStatusString(s)
	return err
}

const _EventLevelName = "无等级低级中级高级"

var _EventLevelIndex = [...]uint8{0, 9, 15, 21, 27}

func (i EventLevel) String() string {
	if i < 0 || i >= EventLevel(len(_EventLevelIndex)-1) {
		return fmt.Sprintf("EventLevel(%d)", i)
	}
	return _EventLevelName[_EventLevelIndex[i]:_EventLevelIndex[i+1]]
}

var _EventLevelValues = []EventLevel{0, 1, 2, 3}

var _EventLevelNameToValueMap = map[string]EventLevel{
	_EventLevelName[0:9]:   0,
	_EventLevelName[9:15]:  1,
	_EventLevelName[15:21]: 2,
	_EventLevelName[21:27]: 3,
}

// EventLevelString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func EventLevelString(s string) (EventLevel, error) {
	if val, ok := _EventLevelNameToValueMap[s]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to EventLevel values", s)
}

// EventLevelValues returns all values of the enum
func EventLevelValues() []EventLevel {
	return _EventLevelValues
}

// IsAEventLevel returns "true" if the value is listed in the enum definition. "false" otherwise
func (i EventLevel) IsAEventLevel() bool {
	for _, v := range _EventLevelValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for EventLevel
func (i EventLevel) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for EventLevel
func (i *EventLevel) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("EventLevel should be a string, got %s", data)
	}

	var err error
	*i, err = EventLevelString(s)
	return err
}
```
